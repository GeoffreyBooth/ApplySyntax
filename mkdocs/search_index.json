{
    "docs": [
        {
            "location": "/", 
            "text": "ApplySyntax\n\n\nDetect and apply syntax in Sublime Text.\n\n\n\n\nOverview\n\n\nApplySyntax is a plugin for Sublime Text 2 and 3 that allows you to detect and apply the syntax of files that might not otherwise be detected properly. For example, files with the \n.rb\n extension are usually Ruby files, but when they are found in a Rails project, they could be RSpec spec files, Cucumber step files, Ruby on Rails files (controllers, models, etc), or just plain Ruby files. This is actually the problem I was trying to solve when I started working on this plugin.\n\n\nCredits\n\n\nDetectSyntax was originally created by phillipkoebbe.  In his words, these are his credits:\n\n\n\n\nIt all started by forking the plugin created by JeanMertz \n(1)\n. I modified it quite extensively until I ended up with something entirely my own \n(2)\n. @maxim and @omarramos commented on the gist and suggested it should be part of Package Control. As I had created it solely for my own consumption, it seemed a bit \nhard-coded\n to be valuable as a package, but then I took a look at SetSyntax \n(3)\n. and saw how using settings would make it very flexible. That set me on the path that led to DetectSyntax.\n\n\n\n\nInstallation\n\n\nApplySyntax can be installed in a variety of ways:\n\n\n\n\n\n\nThrough Package Control \nPackage Control\n\n\n\n\nOpen Package Control\n\n\nSelect \nInstall Package\n\n\nFind and select \nApplySyntax\n\n\n\n\n\n\n\n\nBy cloning this repository in Packages\n\n\n\n\ncd into your Packages folder\n\n\ngit clone git://github.com/facelessuser/ApplySyntax.git\n\n\n\n\n\n\n\n\nBy downloading the files and placing them in a directory under \nPackages/ApplySyntax\n. If you download and extract a compressed archive from GitHub, the directory will be \nfacelessuser-ApplySyntax\n. Remove \nfacelessuser-\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#applysyntax", 
            "text": "Detect and apply syntax in Sublime Text.", 
            "title": "ApplySyntax"
        }, 
        {
            "location": "/#overview", 
            "text": "ApplySyntax is a plugin for Sublime Text 2 and 3 that allows you to detect and apply the syntax of files that might not otherwise be detected properly. For example, files with the  .rb  extension are usually Ruby files, but when they are found in a Rails project, they could be RSpec spec files, Cucumber step files, Ruby on Rails files (controllers, models, etc), or just plain Ruby files. This is actually the problem I was trying to solve when I started working on this plugin.", 
            "title": "Overview"
        }, 
        {
            "location": "/#credits", 
            "text": "DetectSyntax was originally created by phillipkoebbe.  In his words, these are his credits:   It all started by forking the plugin created by JeanMertz  (1) . I modified it quite extensively until I ended up with something entirely my own  (2) . @maxim and @omarramos commented on the gist and suggested it should be part of Package Control. As I had created it solely for my own consumption, it seemed a bit  hard-coded  to be valuable as a package, but then I took a look at SetSyntax  (3) . and saw how using settings would make it very flexible. That set me on the path that led to DetectSyntax.", 
            "title": "Credits"
        }, 
        {
            "location": "/#installation", 
            "text": "ApplySyntax can be installed in a variety of ways:    Through Package Control  Package Control   Open Package Control  Select  Install Package  Find and select  ApplySyntax     By cloning this repository in Packages   cd into your Packages folder  git clone git://github.com/facelessuser/ApplySyntax.git     By downloading the files and placing them in a directory under  Packages/ApplySyntax . If you download and extract a compressed archive from GitHub, the directory will be  facelessuser-ApplySyntax . Remove  facelessuser- .", 
            "title": "Installation"
        }, 
        {
            "location": "/usage/", 
            "text": "User Guide\n\n\nConfiguring and using ApplySyntax.\n\n\n\n\nOverview\n\n\nApplySyntax is based on the idea of creating rules for selecting a certain syntax. You define the rules, the plugin checks them. The first one to pass wins.\n\n\nCreate your own custom rules in \nPackages/User/ApplySyntax.sublime-settings\n. The easiest way to get started is to just copy the default settings file found in \nPackages/ApplySyntax/ApplySyntax.sublime-settings\n to your \nPackages/User\n directory and modify it to meet your needs. Make sure you rename the \ndefault_syntaxes\n key to just syntaxes. If you don\nt, you will overwrite the default syntaxes and they will not work.\n\n\nSee the default settings file for examples.\n\n\nCreating Rules\n\n\nEach rule is a dictionary within the syntax array.  Let\ns take a look at the top level parameters.\n\n\nName\n\n\nname\n is the syntax file that will be applied to a view which meets the criteria defined in the rule.\n\n\nFor syntax files you must specify the path to the syntax file. The plugin is capable of supporting multiple levels of nesting if you need it to. For example, if you had all of your tmLanguage files for Rails organized like this: \nPackages/Rails/Language/*.tmLanguage\n, and you were looking to use the \nRuby Haml.tmLanguage\n file, you would define the syntax to be:\n\n\nname\n:\n \nRails/Language/Ruby Haml\n\n\n\n\n\n\nIf it is desirable for the syntax rule to reference multiple tmLanguage files because it is not known which package will be on a machine, you can set the syntax as an array of names like:\n\n\nname\n:\n \n[\nRSpec\n,\n \nRSpec (snippets and syntax)/Syntaxes/RSpec\n]\n\n\n\n\n\n\nExtensions\n\n\nextensions\n is a convenience option to add a given set of extensions to your language settings file.  By adding the extension to the language settings file, sidebar icons in ST3 will display the proper icon and files will load with the proper syntax via Sublime\ns default extension detection method.  Keep in mind though that other rules can override this.  As \nextensions\n isn\nt really a rule, but just a list that automatically adds the extension to the language settings file, a hit on this array won\nt currently stop ApplySyntax from processing more rules (this may change in the future).\n\n\nApply syntax will create a file \nApplySyntax.ext-list\n in your \nUser\n folder and track which extension it added so that if you remove a rule, ApplySyntax will only remove the extensions it added to the language file in question.\n\n\nIf you do not like this functionality, you can simply disable it by setting the following option in your settings file to \nfalse\n:\n\n\n    \nadd_exts_to_lang_settings\n:\n \ntrue\n,\n\n\n\n\n\n\nMatch\n\n\nmatch\n is a setting that you either include or do not.  When included, you set it to \nall\n.  When set, all rules defined must be met for a match to be considered successful.\n\n\n    \nmatch\n:\n \nall\n\n\n\n\n\n\nSo in this case, all the rules must match for the syntax to be applied:\n\n\n     \nname\n:\n \nHandlebars/Handlebars\n,\n\n     \nmatch\n:\n \nall\n,\n\n     \nrules\n:\n \n[\n\n         \n{\nfile_name\n:\n \n.*\\\\.html$\n},\n\n         \n{\ncontains\n:\n \nscript [^\n]*type=\\\ntext\\\\/x-handlebars\\\n[^\n]*\n}\n\n     \n]\n\n\n\n\n\n\nIn this case, any of the rules can match:\n\n\n    \n{\n\n        \nname\n:\n \nRuby/Ruby\n,\n\n        \nextensions\n:\n \n[\nthor\n,\n \nrake\n,\n \nsimplecov\n,\n \njbuilder\n,\n \nrb\n,\n \npodspec\n,\n \nrabl\n],\n\n        \nrules\n:\n \n[\n\n            \n{\nfile_name\n:\n \n.*(\\\\\\\\|/)Gemfile$\n},\n\n            \n{\nfile_name\n:\n \n.*(\\\\\\\\|/)Capfile$\n},\n\n            \n{\nfile_name\n:\n \n.*(\\\\\\\\|/)Guardfile$\n},\n\n            \n{\nfile_name\n:\n \n.*(\\\\\\\\|/)[Rr]akefile$\n},\n\n            \n{\nfile_name\n:\n \n.*(\\\\\\\\|/)Berksfile$\n},\n\n            \n{\nfile_name\n:\n \n.*(\\\\\\\\|/)[Cc]heffile$\n},\n\n            \n{\nfile_name\n:\n \n.*(\\\\\\\\|/)Thorfile$\n},\n\n            \n{\nfile_name\n:\n \n.*(\\\\\\\\|/)Podfile$\n},\n\n            \n{\nfile_name\n:\n \n.*(\\\\\\\\|/)config.ru$\n},\n\n            \n{\nfile_name\n:\n \n.*\\\\\\\\Vagrantfile(\\\\\\\\..*)?$\n},\n\n            \n{\nfile_name\n:\n \n.*/Vagrantfile(/..*)?$\n},\n\n            \n{\nfile_name\n:\n \n.*\\\\.thor$\n},\n\n            \n{\nfile_name\n:\n \n.*\\\\.rake$\n},\n\n            \n{\nfile_name\n:\n \n.*\\\\.simplecov$\n},\n\n            \n{\nfile_name\n:\n \n.*\\\\.jbuilder$\n},\n\n            \n{\nfile_name\n:\n \n.*\\\\.rb$\n},\n\n            \n{\nfile_name\n:\n \n.*\\\\.podspec$\n},\n\n            \n{\nfile_name\n:\n \n.*\\\\.rabl$\n},\n\n            \n{\nbinary\n:\n \nruby\n}\n\n        \n]\n\n    \n},\n\n\n\n\n\n\nRules\n\n\nrules\n is an array of rules that can be used to target specific files with your defined syntax file.  The rules are processed until the first True result, so order your rules in a way that makes sense to you.\n\n\nFilename Rule\n\n\nFilename rule defines a filename with regex.\n\n\n{\nfile_name\n:\n \n.*\\\\.xml(\\\\.dist)?$\n},\n\n\n\n\n\n\nFirst Line Rule\n\n\nFirst line rule allows you to check if the first line matches a given regex.\n\n\n{\nfirst_line\n:\n \n^\n\\\\?xml\n},\n\n\n\n\n\n\nBinary (Shebang)\n\n\nA \nbinary\n rule does the same thing as a \nfirst_line\n rule that uses a regex to match a shebang.  The difference being that ApplySyntax will construct the regex for you.\n\n\nSo a \nfirst_line\n rule:\n\n\n{\nfirst_line\n:\n \n^#\\\\!(?:.+)ruby\n}\n\n\n\n\n\n\nCan be simplified as:\n\n\n{\nbinary\n:\n \nruby\n}\n\n\n\n\n\n\nFunction Rule\n\n\nThis is an example of using a custom function to decide whether or not to apply this syntax. The source file should be in a plugin folder. \nname\n is the function name and \nsource\n is the file in which the function is contained; you must include the package it resides in, all sub-folders leading to the file, and the actual file name (extension not needed).\n\n\nWhen this function is called, the filename will be passed to it as the only argument. You are free to do whatever you want in your function, just return \nTrue\n or \nFalse\n.  But please be conscious of keeping it quick and light if possible.\n\n\n{\nfunction\n:\n \n{\nname\n:\n \nis_rails_file\n,\n \nsource\n:\n \nApplySyntax/is_rails_file\n}}\n\n\n\n\n\n\nContent Rule\n\n\nSometimes a filename or first line search is just not enough and maybe a function rule is overkill.  In this case, maybe searching content of a file can be enough.  You can search a file\ns content with regex for a specific token via the \ncontains\n rule.\n\n\n{\ncontains\n:\n \nscript [^\n]*type=\\\ntext\\\\/x-handlebars\\\n[^\n]*\n}\n\n\n\n\n\n\n\n\nTip\n\n\nIt is recommended to pair \ncontains\n rules with other rules via the \nmatch\n:\n \nall\n option to ensure you don\nt search every file (which can significantly slow down the editor), and you get good match results. If pairing with other rules, it is advised to pair it after the other required rule(s) to ensure you search the content of as few files as possible.\n\n\nAlso, try to use very specific regex to ensure you don\nt get false positives.\n\n\n\n\nProject Specific Rules\n\n\nTo define project specific syntaxes just add \nproject_syntaxes\n to your project file.  \nproject_syntaxes\n is an array; just add your syntax rules to it, and ApplySyntax will append the rules to the end of your globally defined rules.\n\n\nSettings Options\n\n\nThere are a couple of general settings found in `ApplySyntax.sublime-settings.\n\n\nRe-Raise Exceptions\n\n\nIf an exception occurs when processing a function, should it be re-raised so the user gets feedback? This is really only useful to those writing functions. The average user just wants the plugin to work.  By default, this will be set to \nfalse\n.\n\n\n    \nreraise_exceptions\n:\n \nfalse\n,\n\n\n\n\n\n\nNew File Syntax\n\n\nIf you want to have a syntax applied when new files are created, set \nnew_file_syntax\n to the name of the syntax to use. The format is exactly the same as the \nname\n parameter in the syntax rules mentioned earlier. For example, if you want to have a new file use JavaScript syntax, set \nnew_file_syntax\n to \nJavaScript/JavaScript\n.  The default is \nfalse\n.\n\n\n    \nnew_file_syntax\n:\n \nJavaScript/JavaScript\n,\n\n\n\n\n\n\nAdd Extensions to Language Settings\n\n\nTo enable adding defined extensions to language settings, just set \nadd_exts_to_lang_settings\n to \ntrue\n.  See \nExtensions\n for more info.\n\n\n    \nadd_exts_to_lang_settings\n:\n \ntrue\n,", 
            "title": "User Guide"
        }, 
        {
            "location": "/usage/#user-guide", 
            "text": "Configuring and using ApplySyntax.", 
            "title": "User Guide"
        }, 
        {
            "location": "/usage/#overview", 
            "text": "ApplySyntax is based on the idea of creating rules for selecting a certain syntax. You define the rules, the plugin checks them. The first one to pass wins.  Create your own custom rules in  Packages/User/ApplySyntax.sublime-settings . The easiest way to get started is to just copy the default settings file found in  Packages/ApplySyntax/ApplySyntax.sublime-settings  to your  Packages/User  directory and modify it to meet your needs. Make sure you rename the  default_syntaxes  key to just syntaxes. If you don t, you will overwrite the default syntaxes and they will not work.  See the default settings file for examples.", 
            "title": "Overview"
        }, 
        {
            "location": "/usage/#creating-rules", 
            "text": "Each rule is a dictionary within the syntax array.  Let s take a look at the top level parameters.", 
            "title": "Creating Rules"
        }, 
        {
            "location": "/usage/#name", 
            "text": "name  is the syntax file that will be applied to a view which meets the criteria defined in the rule.  For syntax files you must specify the path to the syntax file. The plugin is capable of supporting multiple levels of nesting if you need it to. For example, if you had all of your tmLanguage files for Rails organized like this:  Packages/Rails/Language/*.tmLanguage , and you were looking to use the  Ruby Haml.tmLanguage  file, you would define the syntax to be:  name :   Rails/Language/Ruby Haml   If it is desirable for the syntax rule to reference multiple tmLanguage files because it is not known which package will be on a machine, you can set the syntax as an array of names like:  name :   [ RSpec ,   RSpec (snippets and syntax)/Syntaxes/RSpec ]", 
            "title": "Name"
        }, 
        {
            "location": "/usage/#extensions", 
            "text": "extensions  is a convenience option to add a given set of extensions to your language settings file.  By adding the extension to the language settings file, sidebar icons in ST3 will display the proper icon and files will load with the proper syntax via Sublime s default extension detection method.  Keep in mind though that other rules can override this.  As  extensions  isn t really a rule, but just a list that automatically adds the extension to the language settings file, a hit on this array won t currently stop ApplySyntax from processing more rules (this may change in the future).  Apply syntax will create a file  ApplySyntax.ext-list  in your  User  folder and track which extension it added so that if you remove a rule, ApplySyntax will only remove the extensions it added to the language file in question.  If you do not like this functionality, you can simply disable it by setting the following option in your settings file to  false :       add_exts_to_lang_settings :   true ,", 
            "title": "Extensions"
        }, 
        {
            "location": "/usage/#match", 
            "text": "match  is a setting that you either include or do not.  When included, you set it to  all .  When set, all rules defined must be met for a match to be considered successful.       match :   all   So in this case, all the rules must match for the syntax to be applied:        name :   Handlebars/Handlebars , \n      match :   all , \n      rules :   [ \n          { file_name :   .*\\\\.html$ }, \n          { contains :   script [^ ]*type=\\ text\\\\/x-handlebars\\ [^ ]* } \n      ]   In this case, any of the rules can match:       { \n         name :   Ruby/Ruby , \n         extensions :   [ thor ,   rake ,   simplecov ,   jbuilder ,   rb ,   podspec ,   rabl ], \n         rules :   [ \n             { file_name :   .*(\\\\\\\\|/)Gemfile$ }, \n             { file_name :   .*(\\\\\\\\|/)Capfile$ }, \n             { file_name :   .*(\\\\\\\\|/)Guardfile$ }, \n             { file_name :   .*(\\\\\\\\|/)[Rr]akefile$ }, \n             { file_name :   .*(\\\\\\\\|/)Berksfile$ }, \n             { file_name :   .*(\\\\\\\\|/)[Cc]heffile$ }, \n             { file_name :   .*(\\\\\\\\|/)Thorfile$ }, \n             { file_name :   .*(\\\\\\\\|/)Podfile$ }, \n             { file_name :   .*(\\\\\\\\|/)config.ru$ }, \n             { file_name :   .*\\\\\\\\Vagrantfile(\\\\\\\\..*)?$ }, \n             { file_name :   .*/Vagrantfile(/..*)?$ }, \n             { file_name :   .*\\\\.thor$ }, \n             { file_name :   .*\\\\.rake$ }, \n             { file_name :   .*\\\\.simplecov$ }, \n             { file_name :   .*\\\\.jbuilder$ }, \n             { file_name :   .*\\\\.rb$ }, \n             { file_name :   .*\\\\.podspec$ }, \n             { file_name :   .*\\\\.rabl$ }, \n             { binary :   ruby } \n         ] \n     },", 
            "title": "Match"
        }, 
        {
            "location": "/usage/#rules", 
            "text": "rules  is an array of rules that can be used to target specific files with your defined syntax file.  The rules are processed until the first True result, so order your rules in a way that makes sense to you.  Filename Rule  Filename rule defines a filename with regex.  { file_name :   .*\\\\.xml(\\\\.dist)?$ },   First Line Rule  First line rule allows you to check if the first line matches a given regex.  { first_line :   ^ \\\\?xml },   Binary (Shebang)  A  binary  rule does the same thing as a  first_line  rule that uses a regex to match a shebang.  The difference being that ApplySyntax will construct the regex for you.  So a  first_line  rule:  { first_line :   ^#\\\\!(?:.+)ruby }   Can be simplified as:  { binary :   ruby }   Function Rule  This is an example of using a custom function to decide whether or not to apply this syntax. The source file should be in a plugin folder.  name  is the function name and  source  is the file in which the function is contained; you must include the package it resides in, all sub-folders leading to the file, and the actual file name (extension not needed).  When this function is called, the filename will be passed to it as the only argument. You are free to do whatever you want in your function, just return  True  or  False .  But please be conscious of keeping it quick and light if possible.  { function :   { name :   is_rails_file ,   source :   ApplySyntax/is_rails_file }}   Content Rule  Sometimes a filename or first line search is just not enough and maybe a function rule is overkill.  In this case, maybe searching content of a file can be enough.  You can search a file s content with regex for a specific token via the  contains  rule.  { contains :   script [^ ]*type=\\ text\\\\/x-handlebars\\ [^ ]* }    Tip  It is recommended to pair  contains  rules with other rules via the  match :   all  option to ensure you don t search every file (which can significantly slow down the editor), and you get good match results. If pairing with other rules, it is advised to pair it after the other required rule(s) to ensure you search the content of as few files as possible.  Also, try to use very specific regex to ensure you don t get false positives.   Project Specific Rules  To define project specific syntaxes just add  project_syntaxes  to your project file.   project_syntaxes  is an array; just add your syntax rules to it, and ApplySyntax will append the rules to the end of your globally defined rules.", 
            "title": "Rules"
        }, 
        {
            "location": "/usage/#settings-options", 
            "text": "There are a couple of general settings found in `ApplySyntax.sublime-settings.  Re-Raise Exceptions  If an exception occurs when processing a function, should it be re-raised so the user gets feedback? This is really only useful to those writing functions. The average user just wants the plugin to work.  By default, this will be set to  false .       reraise_exceptions :   false ,   New File Syntax  If you want to have a syntax applied when new files are created, set  new_file_syntax  to the name of the syntax to use. The format is exactly the same as the  name  parameter in the syntax rules mentioned earlier. For example, if you want to have a new file use JavaScript syntax, set  new_file_syntax  to  JavaScript/JavaScript .  The default is  false .       new_file_syntax :   JavaScript/JavaScript ,   Add Extensions to Language Settings  To enable adding defined extensions to language settings, just set  add_exts_to_lang_settings  to  true .  See  Extensions  for more info.       add_exts_to_lang_settings :   true ,", 
            "title": "Settings Options"
        }
    ]
}